#version 430

layout(local_size_x = 32, local_size_y = 32) in;

layout(push_constant) uniform params {
    uint resolutionX;
    uint resolutionY;
    float time;
} env;

layout(binding = 0, rgba8) uniform image2D resultImage;

float iTime() {
  return env.time;
}

vec2 iResolution() {
  return ivec2(env.resolutionX, env.resolutionY);
}

float sdBox(vec3 p, vec3 b) {
    vec3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float sdSphere(vec3 p, float r) {
    return length(p) - r;
}

vec3 getLightPos() {
    float swing = sin(iTime());
    return vec3(-1.5 + swing, -1.5 - swing, -1.5);
}

float sceneSDF(vec3 p) {
    float box1 = sdBox(p - vec3(-2.0, -3.5, -2.0), vec3(2.0, 0.5, 2.0));
    float box2 = sdBox(p - vec3(-3.5, -2.0, -2.0), vec3(0.5, 2.0, 2.0));
    float box3 = sdBox(p - vec3(-2.0, -2.0, -3.5), vec3(2.0, 2.0, 0.5));

    float cut1 = sdSphere(p - vec3(-1.5, -3.0, -1.5), 1.0);
    float cut2 = sdSphere(p - vec3(-3.0, -1.5, -1.5), 1.0);
    float cut3 = sdSphere(p - vec3(-1.5, -1.5, -3.0), 1.0);

    vec3 lightPos = getLightPos();
    float sphere = sdSphere(p - lightPos, 0.1);

    return min(
        min(max(box1, -cut1), max(box2, -cut2)),
        min(max(box3, -cut3), sphere)
    );
}

vec3 calcNormal(vec3 p) {
    vec2 e = vec2(0.001, 0.0);
    return normalize(vec3(
        sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy),
        sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),
        sceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)
    ));
}

vec3 phongLighting(vec3 pos, vec3 normal, vec3 viewDir) {
    vec3 lightPos = getLightPos();
    vec3 lightDir = normalize(lightPos - pos);

    vec3 ambient = vec3(0.2, 0.2, 0.3);
    vec3 diffuse = vec3(0.5);
    vec3 specular = vec3(0.5);

    float diff = max(dot(normal, lightDir), 0.0);
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);

    return ambient + diff * diffuse + spec * specular;
}

float rayMarch(vec3 ro, vec3 rd, out vec3 hitPos, out bool isLightSphere) {
    float t = 0.0;
    isLightSphere = false;

    for (int i = 0; i < 100; i++) {
        vec3 p = ro + rd * t;
        float d = sceneSDF(p);

        if (d < 0.001) {
            hitPos = p;
            vec3 lightPos = getLightPos();
            if (length(p - lightPos) < 0.15) {
                isLightSphere = true;
            }
            break;
        }

        t += d;
        if (t > 50.0) {  // увеличил дальность
            hitPos = vec3(0.0);
            break;
        }
    }
    return t;
}

mat3 setCamera(vec3 ro, vec3 ta) {
    vec3 cw = normalize(ta - ro);
    vec3 cp = vec3(0.0, 1.0, 0.0);
    vec3 cu = normalize(cross(cw, cp));
    vec3 cv = cross(cu, cw);
    return mat3(cu, cv, cw);
}


void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);

    if (pixel.x >= int(iResolution().x) || pixel.y >= int(iResolution().y)) {
      return;
    }

    vec2 uv = (vec2(pixel) + 0.5 - 0.5 * iResolution()) / iResolution().y;

    vec3 ro = vec3(3.0, 3.0, 3.0);  // безопасная камера
    vec3 ta = vec3(0.0, 0.0, 0.0);
    mat3 ca = setCamera(ro, ta);
    vec3 rd = normalize(ca * vec3(uv, 1.0));

    vec3 hitPos;
    bool isLightSphere;
    float t = rayMarch(ro, rd, hitPos, isLightSphere);

    vec4 color;
    if (t < 50.0) {
        if (isLightSphere) {
            color = vec4(0.8, 0.8, 0.8, 1.0);
        } else {
            vec3 normal = calcNormal(hitPos);
            vec3 viewDir = normalize(ro - hitPos);
            color = vec4(phongLighting(hitPos, normal, viewDir), 1.0);
        }
    } else {
        color = vec4(0.0, 0.0, 0.0, 1.0);
    }

    imageStore(resultImage, pixel, color);
}
