#version 430

layout(local_size_x = 32, local_size_y = 32) in;

layout(push_constant) uniform params
{
  uint resolutionX;
  uint resolutionY;
  float time;
}
env;

layout(binding = 0, rgba8) uniform image2D resultImage;

float iTime()
{
  return env.time;
}

vec2 iResolution()
{
  return ivec2(env.resolutionX, env.resolutionY);
}

float sdBox(vec3 p, vec3 b)
{
  vec3 q = abs(p) - b;
  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float sdSphere(vec3 p, float r)
{
  return length(p) - r;
}

vec3 getLightPos()
{
  float swing = sin(iTime());
  return vec3(-1.5 + swing, -1.5 - swing, -1.5);
}

float sceneSDF(vec3 p)
{
  float box1 = sdBox(p - vec3(-2.0, -3.5, -2.0), vec3(2.0, 0.5, 2.0));
  float box2 = sdBox(p - vec3(-3.5, -2.0, -2.0), vec3(0.5, 2.0, 2.0));
  float box3 = sdBox(p - vec3(-2.0, -2.0, -3.5), vec3(2.0, 2.0, 0.5));

  float cut1 = sdSphere(p - vec3(-1.5, -3.0, -1.5), 1.0);
  float cut2 = sdSphere(p - vec3(-3.0, -1.5, -1.5), 1.0);
  float cut3 = sdSphere(p - vec3(-1.5, -1.5, -3.0), 1.0);

  vec3 lightPos = getLightPos();
  float sphere = sdSphere(p - lightPos, 0.1);

  return min(min(max(box1, -cut1), max(box2, -cut2)), min(max(box3, -cut3), sphere));
}

vec3 calcNormal(vec3 p)
{
  vec2 e = vec2(0.001, 0.0);
  return normalize(vec3(
    sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy),
    sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),
    sceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)));
}

vec3 phongLighting(vec3 pos, vec3 normal, vec3 viewDir)
{
  vec3 lightPos = getLightPos();
  vec3 lightDir = normalize(lightPos - pos);

  vec3 ambient = vec3(0.2, 0.2, 0.3);
  vec3 diffuse = vec3(0.5);
  vec3 specular = vec3(0.5);

  float diff = max(dot(normal, lightDir), 0.0);
  vec3 reflectDir = reflect(-lightDir, normal);
  float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);

  return ambient + diff * diffuse + spec * specular;
}

float rayMarch(vec3 ro, vec3 rd, out vec3 hitPos, out bool isLightSphere)
{
  float t = 0.0;
  isLightSphere = false;

  for (int i = 0; i < 100; i++)
  {
    vec3 p = ro + rd * t;
    float d = sceneSDF(p);

    if (d < 0.001)
    {
      hitPos = p;
      vec3 lightPos = getLightPos();
      if (length(p - lightPos) < 0.15)
      {
        isLightSphere = true;
      }
      break;
    }

    t += d;
    if (t > 50.0)
    { // увеличил дальность
      hitPos = vec3(0.0);
      break;
    }
  }
  return t;
}

mat3 setCamera(vec3 ro, vec3 ta)
{
  vec3 cw = normalize(ta - ro);
  vec3 cp = vec3(0.0, 1.0, 0.0);
  vec3 cu = normalize(cross(cw, cp));
  vec3 cv = cross(cu, cw);
  return mat3(cu, cv, cw);
}


void main()
{
  ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);

  if (pixel.x >= int(iResolution().x) || pixel.y >= int(iResolution().y))
  {
    return;
  }

  vec2 uv = (vec2(pixel) + 0.5 - 0.5 * iResolution()) / iResolution().y;

  vec3 ro = vec3(3.0, 3.0, 3.0); // безопасная камера
  vec3 ta = vec3(0.0, 0.0, 0.0);
  mat3 ca = setCamera(ro, ta);
  vec3 rd = normalize(ca * vec3(uv, 1.0));

  vec3 hitPos;
  bool isLightSphere;
  float t = rayMarch(ro, rd, hitPos, isLightSphere);

  vec4 color;
  if (t < 50.0)
  {
    if (isLightSphere)
    {
      color = vec4(0.8, 0.8, 0.8, 1.0);
    }
    else
    {
      vec3 normal = calcNormal(hitPos);
      vec3 viewDir = normalize(ro - hitPos);
      color = vec4(phongLighting(hitPos, normal, viewDir), 1.0);
    }
  }
  else
  {
    color = vec4(0.0, 0.0, 0.0, 1.0);
  }

  imageStore(resultImage, pixel, color);
}
